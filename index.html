<!DOCTYPE html>
<html>
  <head>
    <title>YouTube Subscriptions Viewer</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="icon"
      type="image/png"
      href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAGASURBVFhH7ZY9TsNAEIX3HKG5QU6QG1B7A27gNDQcICdwQ0GDhEQBDT9NaOBn7QmQ6Gio6Gio6NLg5nvOeNkkG2yiJWKkfdLKO7Oe93bGa1szN5EyP5YyieSL9K3xH0/yQR4XRTFrjbksH+Wp3JN78kqO5L18lSPrv5BH8lBuy115LR/ks/yQgfWN5aE8kDtyW17KkXyS7/JDBtaXyb6tkXtD7slrGckX+SEH1pfJvq2Re0Pu0bqR7MzR+jLZtzVyb8g9WjeSvVm1vkz2bY3cG3KP1o1kb9asL5N9WyP3htyjdSPZm3Xry2Tf1si9Ifdo3Uj2ZsP6Mtm3NXJvyD1aN5K9aVpfJvu2Ru4NuUfrRrI3W9aXyb6tkXtD7tG6kezNtvVlsm9r5N6Qe7RuJHvTsr5M9m2N3Btyj9SNZG92rC+TfVsj94bco3Uj2Ztd68tk39bIvSH3aN1I9mbP+jLZtzVyb8g9WjeSvdm3vkz2bY3cm3/2htyj9f+ELPsC/+NwIiUl5xQAAAAASUVORK5CYII="
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <style>
      body {
        margin: 0;
        font-family: "Roboto", sans-serif;
        background-color: #0f0f0f;
        color: #fff;
      }
      .video-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 20px;
        padding: 20px;
      }
      .video-card {
        background-color: #1f1f1f;
        border-radius: 12px;
        overflow: hidden;
        transition: transform 0.2s;
      }
      .video-card:hover {
        transform: translateY(-2px);
      }
      .video-thumbnail {
        width: 100%;
        aspect-ratio: 16/9;
        object-fit: cover;
        position: relative;
      }
      .video-info {
        padding: 12px;
      }
      .video-title {
        font-size: 1rem;
        font-weight: 500;
        margin-bottom: 8px;
      }
      .channel-name {
        font-size: 0.9rem;
        color: #aaa;
        display: flex;
        align-items: center;
        gap: 4px;
      }
      .verified-badge {
        color: #aaa;
        font-size: 14px;
      }
      .video-stats {
        font-size: 0.9rem;
        color: #aaa;
        margin-top: 4px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .popularity-score {
        position: absolute;
        top: 8px;
        right: 8px;
        background-color: rgba(0, 0, 0, 0.8);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.85rem;
        font-weight: 500;
        color: #fff;
      }
      .toolbar {
        background-color: #1f1f1f;
        padding: 12px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        position: sticky;
        top: 0;
        z-index: 1;
      }
      .time-filter {
        background-color: #303030;
        color: #fff;
        border: none;
        padding: 8px 16px;
        border-radius: 20px;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .time-filter:hover {
        background-color: #404040;
      }
      .time-filter.active {
        background-color: #fff;
        color: #0f0f0f;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      // Import standalone bundle for Preact and HTM
      import {
        html,
        render,
        useEffect,
        useState,
        useMemo,
      } from "https://unpkg.com/htm/preact/standalone.module.js";

      // Import signals separately
      import { signal, computed } from "https://esm.sh/@preact/signals-core";

      const timeRanges = {
        day: { label: "Past day", days: 1 },
        week: { label: "Last week", days: 7 },
        twoweeks: { label: "Last 2 weeks", days: 14 },
        month: { label: "Last month", days: 30 },
      };

      // Create signals using the imported signal function
      const videos = signal([]);
      const selectedTimeRange = signal("week");

      const filteredVideos = computed(() => {
        const now = new Date();
        const cutoffDays = timeRanges[selectedTimeRange.value].days;
        const currentVideos = videos.value;

        console.log("Computing filtered videos");
        console.log("Total videos:", currentVideos.length);
        console.log("Raw videos sample:", currentVideos.slice(0, 1));
        console.log("Cutoff days:", cutoffDays);

        const filtered = currentVideos
          .filter((video) => {
            if (!video.published_date) {
              console.warn("Video missing published_date:", video);
              return false;
            }
            try {
              const videoDate = new Date(video.published_date);
              // Check if date is valid
              if (isNaN(videoDate.getTime())) {
                console.warn("Invalid date:", video.published_date);
                return false;
              }

              // Calculate age in days
              const ageInDays = (now - videoDate) / (1000 * 60 * 60 * 24);
              const shouldInclude = ageInDays <= cutoffDays;

              console.log(
                "Video:",
                video.title,
                "\nAge in days:",
                ageInDays.toFixed(1),
                "\nCutoff days:",
                cutoffDays,
                "\nInclude:",
                shouldInclude
              );
              return shouldInclude;
            } catch (e) {
              console.warn("Error parsing date:", video.published_date, e);
              return false;
            }
          })
          .sort((a, b) => {
            // Sort by performance score
            return b.performance_score - a.performance_score;
          });

        console.log("Filtered videos:", filtered.length);
        if (filtered.length > 0) {
          console.log("Sample filtered video:", filtered[0]);
        }
        return filtered;
      });

      function formatNumber(num) {
        if (num >= 1000000) return (num / 1000000).toFixed(1) + "M";
        if (num >= 1000) return Math.round(num / 1000) + "K";
        return num.toString();
      }

      function getPopularityColor(score) {
        // Convert score to a 0-1 scale
        const normalizedScore = Math.min(Math.max(score, 0), 1);

        // Use HSL for smooth color transitions
        // Red (0) -> Orange (30) -> Green (120)
        // We'll map 0-1 to these hue values
        const hue = normalizedScore * 120;

        return `hsl(${hue}, 80%, 45%)`;
      }

      function formatPopularityScore(views, average_views, subscriber_count) {
        if (!views || !average_views || average_views === 0) return null;

        // Convert to numbers in case they're strings
        views = parseInt(views);
        average_views = parseInt(average_views);
        subscriber_count = parseInt(subscriber_count);

        if (isNaN(views) || isNaN(average_views) || average_views === 0)
          return null;

        // Use the same composite score calculation as the server
        const score =
          (views / average_views) * 0.4 +
          (views / subscriber_count) * 0.4 +
          (views / Math.max(...videoData.map((v) => v.views))) * 0.2;

        return {
          score: score,
          color: getPopularityColor(score),
        };
      }

      function formatDate(dateStr) {
        const date = new Date(dateStr);
        const now = new Date();
        const diff = (now - date) / 1000; // seconds

        if (diff < 3600) return Math.floor(diff / 60) + " minutes ago";
        if (diff < 86400) return Math.floor(diff / 3600) + " hours ago";
        if (diff < 604800) return Math.floor(diff / 86400) + " days ago";
        if (diff < 2592000) return Math.floor(diff / 604800) + " weeks ago";
        return Math.floor(diff / 2592000) + " months ago";
      }

      function formatPerformance(score) {
        return `${Math.round(score * 100)}%`;
      }

      function App() {
        const [error, setError] = useState(null);
        const [videoData, setVideoData] = useState([]);
        const [timeRange, setTimeRange] = useState("week");

        useEffect(() => {
          console.log("Fetching videos...");
          fetch("/api/videos")
            .then((res) => {
              if (!res.ok) {
                return res.json().then((err) => {
                  throw new Error(
                    err.details || err.error || "Failed to fetch videos"
                  );
                });
              }
              return res.json();
            })
            .then((data) => {
              console.log("Received data:", data);
              if (data.length > 0) {
                console.log("First video:", data[0]);
                console.log("First video channel:", data[0].channel);
                console.log(
                  "First video performance score:",
                  data[0].performance_score
                );
              }
              setVideoData(data);
              setError(null);
            })
            .catch((err) => {
              console.error("Error fetching videos:", err);
              setError(err.message);
            });
        }, []);

        // Filter videos based on time range
        const filteredVideos = useMemo(() => {
          const now = new Date();
          const cutoffDays = timeRanges[timeRange].days;

          console.log("Computing filtered videos");
          console.log("Total videos:", videoData.length);
          if (videoData.length > 0) {
            console.log("Sample video:", videoData[0]);
            console.log("Sample video channel:", videoData[0].channel);
            console.log(
              "Sample video performance score:",
              videoData[0].performance_score
            );
          }

          const filtered = videoData
            .filter((video) => {
              if (!video.published_date) {
                console.warn("Video missing published_date:", video);
                return false;
              }
              try {
                const videoDate = new Date(video.published_date);
                // Check if date is valid
                if (isNaN(videoDate.getTime())) {
                  console.warn("Invalid date:", video.published_date);
                  return false;
                }

                // Calculate age in days
                const ageInDays = (now - videoDate) / (1000 * 60 * 60 * 24);
                console.log(
                  `Video ${video.title}: age=${ageInDays.toFixed(
                    1
                  )} days, cutoff=${cutoffDays} days`
                );
                const shouldInclude = ageInDays <= cutoffDays;

                return shouldInclude;
              } catch (e) {
                console.warn("Error parsing date:", video.published_date, e);
                return false;
              }
            })
            .sort((a, b) => {
              // Sort by performance score
              const scoreA = a.performance_score || 0;
              const scoreB = b.performance_score || 0;
              return scoreB - scoreA;
            });

          console.log("Filtered videos:", filtered.length);
          if (filtered.length > 0) {
            console.log("Sample filtered video:", filtered[0]);
            console.log("Sample filtered video channel:", filtered[0].channel);
            console.log(
              "Sample filtered video performance score:",
              filtered[0].performance_score
            );
          }
          return filtered;
        }, [videoData, timeRange]);

        if (error) {
          return html`
            <div style="padding: 20px; text-align: center; color: #ff6b6b;">
              <h2>Error</h2>
              <p>${error}</p>
              <button
                class="time-filter"
                onClick=${() => window.location.reload()}
              >
                Retry
              </button>
            </div>
          `;
        }

        console.log("Rendering with videos:", filteredVideos.length);

        return html`
          <div>
            <div class="toolbar">
              ${Object.entries(timeRanges).map(
                ([key, { label }]) => html`
                  <button
                    class="time-filter ${timeRange === key ? "active" : ""}"
                    onClick=${() => setTimeRange(key)}
                  >
                    ${label}
                  </button>
                `
              )}
            </div>
            <div class="video-grid">
              ${filteredVideos.map(
                (video) => html`
                  <div
                    class="video-card"
                    onClick=${() => window.open(video.url, "_blank")}
                  >
                    <div style="position: relative;">
                      <img
                        class="video-thumbnail"
                        src=${video.thumbnail}
                        alt=${video.title}
                        onerror="this.onerror=null; this.src=this.src.replace('maxresdefault.jpg', 'hqdefault.jpg')"
                      />
                      <span
                        class="popularity-score"
                        style="background-color: ${getPopularityColor(
                          video.performance_score
                        )}"
                      >
                        ${formatPerformance(video.performance_score)}
                      </span>
                    </div>
                    <div class="video-info">
                      <div class="video-title">${video.title}</div>
                      <div class="channel-name">
                        ${video.channel.name}
                        ${video.channel.is_verified &&
                        html`<span class="verified-badge">✓</span>`}
                      </div>
                      <div class="video-stats">
                        <span>${formatNumber(video.views)} views</span>
                        <span>•</span>
                        <span>${formatDate(video.published_date)}</span>
                      </div>
                    </div>
                  </div>
                `
              )}
            </div>
          </div>
        `;
      }

      render(html`<${App} />`, document.getElementById("app"));
    </script>
  </body>
</html>
